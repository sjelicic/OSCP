
# import socket
# buffer = "A" * 1100
# s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 
# connect=s.connect(('192.168.20.10',21)) 
# response = s.recv(1024)
# print response 
# s.send('USER ' + buffer + '\r\n') 
# response = s.recv(1024)
# print response
# s.send('PASS PASSWORD\r\n')
# s.close()


# https://realpython.com/python-sockets/
# Socket Programming in Python (Guide)

#!/usr/bin/python3

# https://docs.python.org/3/library/socket.html
# socket — Low-level networking interface
import socket

bluffer = 'A' * 1100

# https://effbot.org/zone/python-with-statement.htm
# https://stackoverflow.com/questions/1369526/what-is-the-python-keyword-with-used-for
# It allows you to ensure that a resource is "cleaned up" when the code that 
# uses it finishes running, even if exceptions are thrown. 
# It provides 'syntactic sugar' for try/finally blocks.


#Socket Programming HOWTO
#https://docs.python.org/3/howto/sockets.html


#A pair (host, port) is used for the AF_INET (AF_INET being the IPv4) address family, where host is a string representing either a hostname in Internet domain notation like 'daring.cwi.nl' or an IPv4 address like '100.50.200.5', and port is an integer.

# socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None)
# Create a new socket using the given address family, socket type and protocol number. The address family should be AF_INET (the default), AF_INET6, AF_UNIX, AF_CAN, AF_PACKET, or AF_RDS. The socket type should be SOCK_STREAM (the default), SOCK_DGRAM, SOCK_RAW or perhaps one of the other SOCK_ constants. The protocol number is usually zero and may be omitted or in the case where the address family is AF_CAN the protocol should be one of CAN_RAW, CAN_BCM or CAN_ISOTP.

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

# socket.connect(address)
# Connect to a remote socket at address. (The format of address depends on the address family — see above.)

	s.connect(('192.168.72.131', 21))

# socket.recv(bufsize[, flags])
# Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. 

	data_received = s.recv(1024)

# https://www.geeksforgeeks.org/str-vs-repr-in-python/
# The repr() method returns a printable representation of the given object.

print('Received:', repr(data_received))

# socket.send(bytes[, flags])
# Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. 

s.send('USER ' + bluffer + '/r/n')
data_received = s.recv(1024)
print('Received:', repr(data_received)

s.send('PASS PASSWORD\r\n')
#s.close()







